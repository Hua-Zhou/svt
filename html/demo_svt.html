
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>demo_svt</title><meta name="generator" content="MATLAB 7.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2014-06-12"><meta name="DC.source" content="demo_svt.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Singular value decomposition for sparse matrix</a></li><li><a href="#12">Singular value decomposition for structured (sparse + low rank) matrix</a></li><li><a href="#20">Singular value thresholding for sparse matrix</a></li><li><a href="#30">Singular value thresholding for structured (sparse + low rank) matrix</a></li></ul></div><p>We need a functional environment so that the MAtimesVec subfunction can access variables in workspace</p><pre class="codeinput"><span class="keyword">function</span>[] = demo_svt
</pre><h2>Singular value decomposition for sparse matrix<a name="3"></a></h2><pre class="codeinput">clear;
<span class="comment">% Reset random seed</span>
s = RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'Seed'</span>,2014);
RandStream.setGlobalStream(s);
</pre><p>Read in sparse matrices downloaded from The University of Florida Sparse Matrix Collection</p><pre class="codeinput">data = load(<span class="string">'mhd4800b.mat'</span>);
mat = data.mhd4800b;
</pre><p>Size of matrix</p><pre class="codeinput">disp(size(mat));
</pre><pre class="codeoutput">        4800        4800

</pre><p>Sparsity of matrix</p><pre class="codeinput">disp(nnz(mat)/numel(mat));
</pre><pre class="codeoutput">    0.0012

</pre><p>Top 25 singular values/vectors by svt</p><pre class="codeinput">tic;
[u,s,v] = svt(mat,<span class="string">'k'</span>,25);
toc;
</pre><pre class="codeoutput">Elapsed time is 0.510949 seconds.
</pre><p>Top 25 singular values/vectors by Matlab svds</p><pre class="codeinput">tic;
[su,ss,sv] = svds(mat,25);
toc;
</pre><pre class="codeoutput">Elapsed time is 0.184021 seconds.
</pre><p>Full svd</p><pre class="codeinput">tic;
[fu,fs,fv] = svd(full(mat));
toc;
</pre><pre class="codeoutput">Elapsed time is 77.260061 seconds.
</pre><p>Accuracy of solutions provided by svt</p><pre class="codeinput">disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- u*s*v',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   3.5007e-14

</pre><p>Accuracy of solutions provided by svds</p><pre class="codeinput">disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- su*ss*sv',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   3.6604e-14

</pre><h2>Singular value decomposition for structured (sparse + low rank) matrix<a name="12"></a></h2><pre class="codeinput">clear;
<span class="comment">% Reset random seed</span>
s = RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'Seed'</span>,2014);
RandStream.setGlobalStream(s);
</pre><p>Read in sparse matrices downloaded from The University of Florida Sparse Matrix Collection</p><pre class="codeinput">data = load(<span class="string">'mhd4800b.mat'</span>);
mat = data.mhd4800b;
</pre><p>Generation of structured matrix (sparse plus low rank)</p><pre class="codeinput">m = size(mat,1);
n = size(mat,2);
L = randn(m,20);
R = randn(n,20);
LR = L*R';                <span class="comment">% generation of low rank matrix</span>
smat = mat + LR;          <span class="comment">% sparse + low rank</span>
</pre><p>Top 25 singular values/vectors by svt. Function MAtimesVec is defined at end of this file.</p><pre class="codeinput">tic;
[u,s,v] = svt(@MAtimesVec,<span class="string">'m'</span>,m,<span class="string">'n'</span>,n,<span class="string">'k'</span>,25);
toc;
</pre><pre class="codeoutput">Elapsed time is 0.609937 seconds.
</pre><p>Top 25 singular values/vectors by Matlab's svds</p><pre class="codeinput">tic;
[su,ss,sv] = svds(smat,25);
toc;
</pre><pre class="codeoutput">Elapsed time is 24.889951 seconds.
</pre><p>Full svd</p><pre class="codeinput">tic;
[fu,fs,fv] = svd(full(smat));
toc;
</pre><pre class="codeoutput">Elapsed time is 53.589307 seconds.
</pre><p>Accuracy of solutions provided by svt</p><pre class="codeinput">disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- u*s*v',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   2.9232e-09

</pre><p>Accuracy of solutions provided by svds</p><pre class="codeinput">disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- su*ss*sv',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   5.9058e-09

</pre><h2>Singular value thresholding for sparse matrix<a name="20"></a></h2><pre class="codeinput">clear;
<span class="comment">% Reset random seed</span>
s = RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'Seed'</span>,2014);
RandStream.setGlobalStream(s);
</pre><p>Read in sparse matrices downloaded from The University of Florida Sparse Matrix Collection</p><pre class="codeinput">data = load(<span class="string">'mhd4800b.mat'</span>);
mat = data.mhd4800b;
</pre><p>Size of matrix:</p><pre class="codeinput">disp(size(mat));
</pre><pre class="codeoutput">        4800        4800

</pre><p>Sparsity of matrix</p><pre class="codeinput">disp(nnz(mat)/numel(mat));
</pre><pre class="codeoutput">    0.0012

</pre><p>Find all singular values &gt;= 0.1 by svt (deflation method)</p><pre class="codeinput">tic;
[u,s,v] = svt(mat,<span class="string">'lambda'</span>,0.1);
toc;
display(size(s));
</pre><pre class="codeoutput">Elapsed time is 1.207644 seconds.

ans =

    48    48

</pre><p>It's faster if we have a good guess of how many singular values above threshold</p><pre class="codeinput">tic;
[~,ks,~] = svt(mat,<span class="string">'lambda'</span>,0.1,<span class="string">'k'</span>,45);
toc;
display(size(ks));
</pre><pre class="codeoutput">Elapsed time is 0.612205 seconds.

ans =

    48    48

</pre><p>Find all singular values &gt;= 0.1 by svt (succession method)</p><pre class="codeinput">tic;
[iu,is,iv] = svt(mat,<span class="string">'lambda'</span>,0.1,<span class="string">'method'</span>,<span class="string">'succession'</span>);
toc;
display(size(is));
</pre><pre class="codeoutput">Elapsed time is 2.133169 seconds.

ans =

    48    48

</pre><p>Find all singular values &gt;= 0.1 by full svd</p><pre class="codeinput">fmat = full(mat);
tic;
[su,ss,sv] = svd(fmat);
dss = diag(ss);
i = find(dss&lt;=0.1);
su = su(:,1:i-1);
dss = dss(1:i-1);
sv = sv(:,1:i-1);
ss = diag(dss);
toc;
display(size(ss));
</pre><pre class="codeoutput">Elapsed time is 76.116814 seconds.

ans =

    48    48

</pre><p>Accuracy of solutions provided by svt deflation method</p><pre class="codeinput">disp(norm(u*s*v'- su*ss*sv',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   2.1590e-11

</pre><p>Accuracy of solutions provided by svt succession method</p><pre class="codeinput">disp(norm(iu*is*iv'- su*ss*sv',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   2.6418e-13

</pre><h2>Singular value thresholding for structured (sparse + low rank) matrix<a name="30"></a></h2><pre class="codeinput">clear;
<span class="comment">% Reset random seed</span>
s = RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'Seed'</span>,2014);
RandStream.setGlobalStream(s);
</pre><p>Read in sparse matrices downloaded from The University of Florida Sparse Matrix Collection</p><pre class="codeinput">data = load(<span class="string">'mhd4800b.mat'</span>);
mat = data.mhd4800b;
</pre><p>Generation of structured matrix (sparse plus low rank)</p><pre class="codeinput">m = size(mat,1);
n = size(mat,2);
L = randn(m,20);
R = randn(n,20);
LR = L*R';                <span class="comment">% generation of low rank matrix</span>
smat = mat + LR;          <span class="comment">% sparse + low rank</span>
</pre><p>Find all singular values &gt;= 0.2 by svt (deflation method). Function MAtimesVec is defined at end of this file.</p><pre class="codeinput">tic;
[u,s,v] = svt(@MAtimesVec,<span class="string">'m'</span>,m,<span class="string">'n'</span>,n,<span class="string">'lambda'</span>,0.2);
toc;
display(size(s));
</pre><pre class="codeoutput">Warning: eflag is 1, refresh with
warm start. 
Elapsed time is 2.786947 seconds.

ans =

    48    48

</pre><p>It's faster if we have a good guess of how many singular values above threshold</p><pre class="codeinput">tic;
[~,ks,~] = svt(@MAtimesVec,<span class="string">'m'</span>,m,<span class="string">'n'</span>,n,<span class="string">'lambda'</span>,0.2,<span class="string">'k'</span>,45);
toc;
display(size(ks));
</pre><pre class="codeoutput">Elapsed time is 2.249316 seconds.

ans =

    48    48

</pre><p>Find all singular values &gt;= 0.2 by svt (succession method). Function MAtimesVec is defined at end of this file.</p><pre class="codeinput">tic;
[iu,is,iv] = svt(@MAtimesVec,<span class="string">'m'</span>,m,<span class="string">'n'</span>,n,<span class="string">'lambda'</span>,0.2,<span class="keyword">...</span>
<span class="string">'method'</span>,<span class="string">'succession'</span>);
toc;
display(size(is));
</pre><pre class="codeoutput">Elapsed time is 13.677045 seconds.

ans =

    48    48

</pre><p>Find all singular values &gt;= 0.2 by full svd</p><pre class="codeinput">fmat = full(smat);
tic;
[su,ss,sv] = svd(fmat);
dss = diag(ss);
i = find(dss&lt;=0.2);
su = su(:,1:i-1);
dss = dss(1:i-1);
sv = sv(:,1:i-1);
ss = diag(dss);
toc;
display(size(ss));
</pre><pre class="codeoutput">Elapsed time is 53.285508 seconds.

ans =

    48    48

</pre><p>Accuracy of solutions provided by svt deflation method</p><pre class="codeinput">disp(norm(u*s*v'- su*ss*sv',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   2.6775e-10

</pre><p>Accuracy of solutions provided by svt succession method</p><pre class="codeinput">disp(norm(iu*is*iv'- su*ss*sv',<span class="string">'fro'</span>));
</pre><pre class="codeoutput">   7.2609e-10

</pre><p>Subfunction for exploiting matrix structure of sparse plus low rank</p><pre class="codeinput"><span class="keyword">function</span> MAvec = MAtimesVec(vec, trans)

    <span class="keyword">if</span> trans
       MAvec = (vec'*mat)' + R*(vec'*L)';
    <span class="keyword">else</span>
       MAvec = mat*vec + L*(R'*vec);
    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.12<br></p></div><!--
##### SOURCE BEGIN #####
%%
% We need a functional environment so that the MAtimesVec subfunction can
% access variables in workspace
function[] = demo_svt

%% Singular value decomposition for sparse matrix

clear;
% Reset random seed
s = RandStream('mt19937ar','Seed',2014);
RandStream.setGlobalStream(s);

%%
% Read in sparse matrices downloaded from The University of Florida Sparse
% Matrix Collection
data = load('mhd4800b.mat');
mat = data.mhd4800b;

%%
% Size of matrix
disp(size(mat));

%%
% Sparsity of matrix
disp(nnz(mat)/numel(mat)); 

%%
% Top 25 singular values/vectors by svt
tic;
[u,s,v] = svt(mat,'k',25);
toc;

%%
% Top 25 singular values/vectors by Matlab svds
tic;
[su,ss,sv] = svds(mat,25);
toc;

%%
% Full svd
tic;
[fu,fs,fv] = svd(full(mat));
toc;

%%
% Accuracy of solutions provided by svt
disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- u*s*v','fro')); 

%%
% Accuracy of solutions provided by svds
disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- su*ss*sv','fro')); 

%% Singular value decomposition for structured (sparse + low rank) matrix

clear;
% Reset random seed
s = RandStream('mt19937ar','Seed',2014);
RandStream.setGlobalStream(s);

%%
% Read in sparse matrices downloaded from The University of Florida Sparse
% Matrix Collection
data = load('mhd4800b.mat');
mat = data.mhd4800b;

%%
% Generation of structured matrix (sparse plus low rank)
m = size(mat,1);
n = size(mat,2);
L = randn(m,20);  
R = randn(n,20);
LR = L*R';                % generation of low rank matrix
smat = mat + LR;          % sparse + low rank

%%
% Top 25 singular values/vectors by svt. Function MAtimesVec is defined at
% end of this file.
tic;
[u,s,v] = svt(@MAtimesVec,'m',m,'n',n,'k',25);
toc;

%%
% Top 25 singular values/vectors by Matlab's svds
tic;
[su,ss,sv] = svds(smat,25);
toc;

%%
% Full svd
tic;
[fu,fs,fv] = svd(full(smat));
toc;

%%
% Accuracy of solutions provided by svt
disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- u*s*v','fro')); 

%%
% Accuracy of solutions provided by svds
disp(norm(fu(:,1:25)*fs(1:25,1:25)*fv(:,1:25)'- su*ss*sv','fro')); 

%% Singular value thresholding for sparse matrix

clear;
% Reset random seed
s = RandStream('mt19937ar','Seed',2014);
RandStream.setGlobalStream(s);

%%
% Read in sparse matrices downloaded from The University of Florida Sparse
% Matrix Collection
data = load('mhd4800b.mat');
mat = data.mhd4800b;

%%
% Size of matrix:
disp(size(mat));

%%
% Sparsity of matrix
disp(nnz(mat)/numel(mat));

%%
% Find all singular values >= 0.1 by svt (deflation method)
tic;
[u,s,v] = svt(mat,'lambda',0.1);
toc;
display(size(s));

%%
% It's faster if we have a good guess of how many singular values above
% threshold
tic;
[~,ks,~] = svt(mat,'lambda',0.1,'k',45);
toc;
display(size(ks));

%%
% Find all singular values >= 0.1 by svt (succession method)
tic;
[iu,is,iv] = svt(mat,'lambda',0.1,'method','succession');
toc;
display(size(is));

%%
% Find all singular values >= 0.1 by full svd
fmat = full(mat);
tic;
[su,ss,sv] = svd(fmat);
dss = diag(ss);
i = find(dss<=0.1);
su = su(:,1:i-1);
dss = dss(1:i-1);
sv = sv(:,1:i-1);
ss = diag(dss);
toc;
display(size(ss));

%%
% Accuracy of solutions provided by svt deflation method
disp(norm(u*s*v'- su*ss*sv','fro')); 

%%
% Accuracy of solutions provided by svt succession method
disp(norm(iu*is*iv'- su*ss*sv','fro')); 

%% Singular value thresholding for structured (sparse + low rank) matrix 

clear;
% Reset random seed
s = RandStream('mt19937ar','Seed',2014);
RandStream.setGlobalStream(s);

%%
% Read in sparse matrices downloaded from The University of Florida Sparse
% Matrix Collection
data = load('mhd4800b.mat'); 
mat = data.mhd4800b;

%%
% Generation of structured matrix (sparse plus low rank)
m = size(mat,1);
n = size(mat,2);
L = randn(m,20);  
R = randn(n,20);
LR = L*R';                % generation of low rank matrix
smat = mat + LR;          % sparse + low rank

%%
% Find all singular values >= 0.2 by svt (deflation method). Function
% MAtimesVec is defined at end of this file.
tic;
[u,s,v] = svt(@MAtimesVec,'m',m,'n',n,'lambda',0.2);
toc;
display(size(s));

%%
% It's faster if we have a good guess of how many singular values above
% threshold
tic;
[~,ks,~] = svt(@MAtimesVec,'m',m,'n',n,'lambda',0.2,'k',45);
toc;
display(size(ks));

%%
% Find all singular values >= 0.2 by svt (succession method). Function
% MAtimesVec is defined at end of this file.
tic;
[iu,is,iv] = svt(@MAtimesVec,'m',m,'n',n,'lambda',0.2,...
'method','succession');
toc;
display(size(is));

%%
% Find all singular values >= 0.2 by full svd
fmat = full(smat);
tic;
[su,ss,sv] = svd(fmat);
dss = diag(ss);
i = find(dss<=0.2);
su = su(:,1:i-1);
dss = dss(1:i-1);
sv = sv(:,1:i-1);
ss = diag(dss);
toc;
display(size(ss));

%%
% Accuracy of solutions provided by svt deflation method
disp(norm(u*s*v'- su*ss*sv','fro')); 

%%
% Accuracy of solutions provided by svt succession method
disp(norm(iu*is*iv'- su*ss*sv','fro')); 

%%
% Subfunction for exploiting matrix structure of sparse plus low rank
function MAvec = MAtimesVec(vec, trans)

    if trans
       MAvec = (vec'*mat)' + R*(vec'*L)';
    else
       MAvec = mat*vec + L*(R'*vec);
    end
    
end

end





##### SOURCE END #####
--></body></html>